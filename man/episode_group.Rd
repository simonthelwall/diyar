% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/episode_group.R
\name{episode_group}
\alias{episode_group}
\title{Episode grouping}
\usage{
episode_group(df, sn = NULL, strata = NULL, date, episode_length,
  episode_type = "static", episodes_max = Inf,
  rc_episode_length = NULL, rolls_max = Inf, data_source = NULL,
  source_sort = FALSE, from_last = FALSE, display = TRUE)
}
\arguments{
\item{df}{Dataframe. One or more datasets appened together.}

\item{sn}{Unique record indentifier for the dataframe}

\item{strata}{Column names. Episode grouping will be straified by these columns and will be unique to each strata}

\item{date}{Record date. A column of \code{date} type}

\item{episode_length}{Episode duration/window in calendar days. Integer values between \code{0} and \code{Inf}, and should be unique to each \emph{strata}.}

\item{episode_type}{\emph{"static"} or \emph{"rolling"}. If \emph{"static"}, each episode will only include records within a fixed period \code{episode_length} from the inital record (case). If \emph{"rolling"}, will include recurrent records. \strong{See \code{rc_episode_length}}}

\item{episodes_max}{Maximum number of episodes permitted in each strata. An integer between \code{0} and \code{Inf}.}

\item{rc_episode_length}{Period of recurrence in calendar days. Recurrence here refers to records ocurring after \code{episode_length} of the first record but within the \code{rc_episode_length} of the last duplicate record. Only used if \code{episode_type}`is \emph{"rolling"}. Should also be unique to each strata. Integer value between \code{0} and \code{Inf}}

\item{rolls_max}{Maximum number of recurrence within each episode. Integer between \code{0} and \code{Inf}. Only used if \code{episode_type} is \emph{"rolling"}.}

\item{data_source}{Unique dataset indentifier for the dataframe. Usefull when dataframe contains multiple datsets.}

\item{source_sort}{If \code{TRUE}, "Case" assignment is done in preference to the data source. Usefull in specifying that cases come from a particular dataset within the dataframe regardless of chronological order.}

\item{from_last}{If \code{TRUE}, episode grouping will be backwards in time - starting from the most recent record to the earliest. If \code{FALSE}, it'll be forward in time - starting from the earliest record to most recent.}

\item{display}{If \code{TRUE}, progress status at each stage of episode grouping is displayed on screen}
}
\value{
Dataframe with a unique episode identifier, type of record based on the episode length and type, and if selected,
a list of datasets where each episode was identified
}
\description{
This function assigns records into unique chronological episodes
}
\examples{


library(lubridate)
library(dplyr)

data <- data.frame(date = seq.Date(dmy("01/04/2018"), dmy("31/05/2018"), by="3 days"))
data$pid <- "Patient 1"
data$episode_len <- 7
data <- mutate(data, rd_id = row_number())

cbind(head(data,10),
      episode_group(head(data,10), sn=rd_id, strata = pid, date = date, episode_length = episode_len)
      )

# The progress updates are displayed and can be disabled by setting "display" to FALSE
cbind(head(data,10),
      episode_group(head(data,10), sn=rd_id, strata = pid, date = date, episode_length = episode_len, display = FALSE)
      )

# By default, episode grouping starts from the earliest record of within each strata and proceeds forward in time. The reverse can be achieved by setting "from_last" to TRUE
# Below is an example of episode grouping from both directions with an episode length of 13 calendar days
data_2 <- mutate(head(data,10), episode_len_s=13)

cbind(data_2,
      select(episode_group(data_2, sn=rd_id, strata = pid, date = date, episode_length = episode_len_s, display = FALSE, from_last = FALSE), -sn, epid.1=epid, case.1=case_nm),
      select(episode_group(data_2, sn=rd_id, strata = pid, date = date, episode_length = episode_len_s, display = FALSE, from_last = TRUE), -sn, epid.2=epid, case.2=case_nm)
      )

# By deafult, "episode_type" is set to "static". This assumes an episode does not re-occur after a fixed number of days from the inital record (episode_length), refered to as the "Case".
# Conversely, chosing an "episode_type" of "rolling" will assume a record can re-occur if it's within a fixed number of days after the most recent report within the episode ("rc_episode_length"), this could be a "Case" or "Duplicate" record.
# When "episode_type" is "rolling", The "Case", "Duplicates" of the "Case", "Recurrent" record, and "Duplicates" of the "Recurrent" record are assigned to the same episode.
# The example below demonstrates this

cbind(data_2,
      select(episode_group(data_2, sn=rd_id, strata = pid, date = date, episode_length = episode_len_s, episode_type ="rolling", display = FALSE, from_last = FALSE), -sn, epid.1=epid, case.1=case_nm),
      select(episode_group(data_2, sn=rd_id, strata = pid, date = date, episode_length = episode_len_s, episode_type ="rolling", display = FALSE, from_last = TRUE), -sn, epid.2=epid, case.2=case_nm)
      )

# By default, the window period for the "Recurrent" record is the same as that for the "Case" (episode_length).
# However, a different "rc_episode_length" can be used.
# The example below demonsrates the difference between using the same "episode_length" and "rc_episode_length" (13 calendar days) compared to an "episode_length" of 13 days and an "rc_episode_length" of 30 days.

data_4 <- mutate(data_2, recurrence=30)
cbind(data_4,
      select(episode_group(data_4, sn=rd_id, strata = pid, date = date, episode_length = episode_len, episode_type ="rolling", display = FALSE), -sn, epid.1=epid, case.1=case_nm),
      select(episode_group(data_4, sn=rd_id, strata = pid, date = date, episode_length = episode_len, episode_type ="rolling", rc_episode_length = recurrence, display = FALSE), -sn, epid.2=epid, case.2=case_nm)
      )
# Both scenerio yield one episode and therefore one "Case" however, the first 4 "Recurrent" records while the second has only 2 "Recurrent" records.

# By default, the function will assume a record can continue to re-occur indefinitely until there is no chronological record within the "rc_episode_length" of the most recent record in the epsiode.
# The "rolls_max" argument can be used to set the number of times an episode can re-occur as defined above
# Once "rolls_max" is reached the next chronological records is assigned to a new episode even if it's within the "rc_episode_length" of most recent record.
# The example below demonsrates the difference between an Infinite "roll_max" (default) and a "rolls_max" of 1.

data_4 <- mutate(data_4, recurrence=4)
cbind(data_4,
      select(episode_group(data_4, sn=rd_id, strata = pid, date = date, episode_length = episode_len_s, episode_type ="rolling", rc_episode_length = recurrence, display = FALSE), -sn, epid.1=epid, case.1=case_nm),
      select(episode_group(data_4, sn=rd_id, strata = pid, date = date, episode_length = episode_len_s, episode_type ="rolling", rc_episode_length = recurrence, rolls_max = 1,  display = FALSE), -sn, epid.2=epid, case.2=case_nm)
      )
# Note a "rolls_max" of "0" will have the result as as when "episode_type" is "static". See below.

cbind(data_4,
      select(episode_group(data_4, sn=rd_id, strata = pid, date = date, episode_length = episode_len_s, episode_type ="static", rc_episode_length = recurrence, display = FALSE), -sn, epid.1=epid, case.1=case_nm),
      select(episode_group(data_4, sn=rd_id, strata = pid, date = date, episode_length = episode_len_s, episode_type ="rolling", rc_episode_length = recurrence, rolls_max = 0,  display = FALSE), -sn, epid.2=epid, case.2=case_nm)
      )

# Similarly, by default, the function will group every record within a strata into epsiodes.
# The "episodes_max" argument can be used to set the number of times records are time records are grouped into episodes.
# Once "episodes_max" is reached, subsequent records are assigned to new distinct episodes ids.
# The example below demonsrates the difference between an Infinite "episode_max" (default) and an "episode_max" of 1.

cbind(data_4,
      select(episode_group(data_4, sn=rd_id, strata = pid, date = date, episode_length = episode_len_s, episode_type ="static", rc_episode_length = recurrence, episodes_max = 1, display = FALSE), -sn, epid_l=epid, case_l=case_nm),
      select(episode_group(data_4, sn=rd_id, strat = pid, date = date, episode_length = episode_len_s, episode_type ="static", rc_episode_length = recurrence, episodes_max = 2,  display = FALSE), -sn, epid_s=epid, case_s=case_nm)
      )

# Note that "rolls_max" and "episodes_max" controls different aspects of episode grouping hence their behaviours are not always interchangeble.
# For instance, the example below will gives different result when a "episodes_max" and "rolls_max" of 2

data_5 <- mutate(data_4, recurrence=3)
# 13 day episode length
cbind(data_5,
      select(episode_group(data_5, sn=rd_id, strata = pid, date = date, episode_length = episode_len_s, episode_type ="rolling", rc_episode_length = recurrence, episodes_max = 2, display = FALSE), -sn, epid_l=epid, case_l=case_nm),
      select(episode_group(data_5, sn=rd_id, strata = pid, date = date, episode_length = episode_len_s, episode_type ="rolling", rc_episode_length = recurrence, rolls_max = 2,  display = FALSE), -sn, epid_s=epid, case_s=case_nm)
      )

# While the one below will not

# 7 day episode length
cbind(data_5,
      select(episode_group(data_5, sn=rd_id, strata = pid, date = date, episode_length = episode_len, episode_type ="rolling", rc_episode_length = recurrence, episodes_max = 2, display = FALSE), -sn, epid_l=epid, case_l=case_nm),
      select(episode_group(data_5, sn=rd_id, strata = pid, date = date, episode_length = episode_len, episode_type ="rolling", rc_episode_length = recurrence, rolls_max = 2,  display = FALSE), -sn, epid_s=epid, case_s=case_nm)
      )

# If the dataframe contains multiple datasets use the "data_source" argument to show which datasets have been grouped into particular epsiodes
data_6 <- data_5
data_6$dataset <- paste("DS",c(1:3, rep(c(1:2),2), rep(3,3)), sep="")

cbind(data_6,
      select(episode_group(data_6, sn=rd_id, strata = pid, date = date, episode_length = episode_len, episode_type ="rolling", rc_episode_length = recurrence, data_source = dataset, display = FALSE), -sn, epid_l=epid, case_l=case_nm, epid_grp_l=epid_grp)
)
}
